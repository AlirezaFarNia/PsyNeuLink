--------
BIDS Model Description Format (BIDS-MDF) 
--------

Introduction
------------
The purpose of the BIDS-MSF is to provide a standard, JSON-based format for describing computatonal models of
brain and/or mental function.  The goal is to provide a common exchange format that allows models created in one
environment that supports the standard to be expressed in a form -- and in sufficient detail -- that it can be
imported into another modeling environment that supports the standard, and then executed in that environment with
identical results,  and/or integrated with other models in that environment. 
    
The format assumes that models can be expressed as graphs, in which each node is a computational component, and edges
specify connections between them that (at least partially) determine the flow of computation.  In this respect,
they are similar to more generic forms of computational graphs.  However the standard supports the expression of
more specific elements within nodes and edges that are central to models of brain function (e.g., the inclusion of
"ports" in nodes that are dedicdated to processing the input and/or output of a node; and the "weight" and/or "function" 
of an edge that allows it to do more than simply relay information unmodified from one node to another.  Finally, the
standard allows elements that are specific to a particular modeling environment to be expressed in a circumscribed
form, so that the format can be used to "serialize" models from that environment, and makes them accessible to other
environments that specifically support those constructs from the origin environment.  This latter capability provides
a way not only for extending the standard to accomodate the specific needs of individual environments, but also as a
path toward extending the standard:  recurring extensions that serve similar purposes help identify targets for the
definition of new components of the core standard itself. 
            

Overall structure
-----------------

The BIDS-MDF is a hierarchically orgainzed format using JSON-compliant syntax, that can be used to describe one or model
models in a single text file.  The outermost level of the specificaton is a dictionary with a single entry named
``graphs``, the value of which is a ``list`` of  **graph** objects.  Each **graph** object is a dictionary that
defines a single model.  Each **graph** dictionary must have at least two entries, named **nodes** and **edges**. 
Each entry in the **node** and **edge** dictionaries is itself a dictionary that contains object-specifific
entries.  A **node** entry can contain a graph, that can be used to describe hierarchically-structured models.
The outermost structure of the JSON specification looks like this: 

    {
        "graphs": [
            {
                "nodes": {
                    ... node entries
                }
                "edges": {
                    ... edge entries
                }
             }
         ]
     }



Where a modeling environment requires specification of objects or other information
not (yet) supported by the standard, environment-specific entries can be included using a name for the environment as
the entry's key.  In the examples below, PsyNeuLink (PNL) is used to demonstrate such environment-specific entries.

Entries common to all objects
-----------------------------

Every entry can have the 

* ``name`` : a label for the object

* ``parameters`` (non-**function**s) / ``args`` (**function**s) : a dictionary where each entry is either a
  parameter name and value, or a subdictionary of modeling-environment specific parameter-value pairs.


    "args": {
        "PNL": {
            "execution_count": 0,
            "has_initializers": false,
            "variable": [
                0.01
            ]
        },
        "bounds": null,
        "intercept": 0.0,
        "slope": 1.0
    }

Note that the value of a parameter may be a long-form dictionary when it corresponds to a **port**.
In this case, it will indicate the **port** in a `source` field:


    "intercept": {
        "source": "A.input_ports.intercept",
        "type": "float",
        "value": 2.0
    }

* ``type`` : a dictionary with entries based on modeling environment to describe the type of the object.
  The `generic` entry is populated if the object has a universal name (such as a linear function).
  Modeling-environment-specific entries are populated when relevant:


    "type": {
        "PNL": "Composition",
        "generic": "graph"
    }


**Nodes**, **edges**, and **ports** each have:

* ``functions`` : a list of **function** JSON objects.


    "functions": [
        {
            "args": {
                "intercept": {
                    "source": "A.input_ports.intercept",
                    "type": "float",
                    "value": 2.0
                },
                "slope": {
                    "source": "A.input_ports.slope",
                    "type": "float",
                    "value": 5.0
                }
            },
            "name": "Linear Function-1",
            "type": {
                "generic": "Linear"
            }
        }
    ]

Non-**graph** **Nodes** have:

* ``input_ports`` : a list of input and parameter *port* JSON objects

* ``output_ports`` : a list of output *port* JSON objects

**Edges** have:

* ``sender`` : the name of the *node* it projects from

* ``sender_port`` : the name of the port on the ``sender`` to which it connects

* ``receiver`` : the name of the *node* it projects to

* ``receiver_port`` : the name of the port on the ``receiver`` to which it connects

**Ports** have:

* ``dtype`` : the type of accepted input/output for the Port. This corresponds to [numpy.dtype](https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html>)

* ``shape`` : the shape of the accepted input/output. This corresponds \
to numpy ndarray shapes. (`numpy.zeros(<shape>)` would produce an \
array with the correct shape)

**Graphs** have:

* ``nodes`` : a dictionary of Mechanisms or Compositions keyed on \
their names that are part of the Composition

* ``edges`` : a dictionary of Projections keyed on their names that \
connect nodes of the Composition

* ``controller`` : the name of the **node** in the **graph**'s node list that serves as the graph's controller, if it exists
